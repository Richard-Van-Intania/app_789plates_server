use std::collections::HashMap;

use axum::{
    extract::{Query, State},
    Json,
};
use chrono::{DateTime, Utc};
use hyper::StatusCode;
use serde::{Deserialize, Serialize};

use crate::app_state::AppState;

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct PlatesQuery {
    pub plates_id: i32,
    pub front_text: String,
    pub plates_type_id: i32,
    pub plates_uri: Option<String>,
    pub total: i32,
    pub front_number: i32,
    pub back_number: i32,
    pub users_id: i32,
    pub special_front_id: i32,
    pub province_id: i32,
    pub information: Option<String>,
    pub price: i32,
    pub name: String,
    pub profile_uri: Option<String>,
    pub liked_plates_id: Option<i32>,
    pub saved_plates_id: Option<i32>,
    pub reacts: i32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PlatesData {}

pub async fn query_plates_pattern(
    Query(params): Query<HashMap<String, String>>,
    State(AppState { pool, client: _ }): State<AppState>,
) -> Result<Json<Vec<PlatesQuery>>, StatusCode> {
    let price_under = match params.get("price_under") {
        Some(some) => match some.parse::<i32>() {
            Ok(ok) => ok,
            Err(_) => return Err(StatusCode::BAD_REQUEST),
        },
        None => return Err(StatusCode::BAD_REQUEST),
    };
    let sort_by = match params.get("sort_by") {
        Some(some) => some.to_string(),
        None => return Err(StatusCode::BAD_REQUEST),
    };
    let plates_type_list = match params.get("plates_type_list") {
        Some(some) => some.to_string(),
        None => return Err(StatusCode::BAD_REQUEST),
    };
    let province_list = match params.get("province_list") {
        Some(some) => some.to_string(),
        None => return Err(StatusCode::BAD_REQUEST),
    };
    let fetch: Result<Vec<PlatesQuery>, sqlx::Error> = sqlx::query_as("").fetch_all(&pool).await;

    todo!()
}

pub async fn search_plates(
    Query(params): Query<HashMap<String, String>>,
    State(AppState { pool, client: _ }): State<AppState>,
) -> Result<Json<Vec<PlatesQuery>>, StatusCode> {
    todo!()
}

pub async fn query_dev(
    State(AppState { pool, client: _ }): State<AppState>,
    Json(payload): Json<PlatesFilter>,
) -> Result<Json<Vec<PlatesDev>>, StatusCode> {
    let fetch: Result<Vec<PlatesDev>, sqlx::Error> = sqlx::query_as(
        "SELECT *
FROM public.plates
WHERE plates_type_id IN (
        SELECT unnest (1)
    )
    AND province_id IN (
        SELECT unnest (2)
    )
ORDER BY plates_id ASC",
    )
    .bind(payload.plates_type_id_list)
    .bind(payload.province_id_list)
    .fetch_all(&pool)
    .await;
    match fetch {
        Ok(ok) => Ok(Json(ok)),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}




